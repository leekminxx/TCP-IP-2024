# TCP-IP-2024
TCP/IP-2024


## 1일차 
- TCP/IP - cmd > ipconfig
    - 전송방식: TCP / UDP 
       - TCP (Transmission Control Protocol)
            - 연결 지향적: 데이터 전송 전에 송신자와 수신자 간에 연결을 확립
            - 신뢰성: 데이터가 손실되거나 손상되지 않도록 보장합니다. 손실된 데이터는 재전송
            - 데이터 순서 보장: 송신한 순서대로 데이터가 수신
            - 흐름 제어 및 혼잡 제어: 네트워크 혼잡을 방지하기 위해 데이터 전송 속도를 조절

       - UDP (User Datagram Protocol)

            - 비연결 지향적: 데이터 전송 전에 연결을 확립하지 않음
            - 신뢰성 부족: 데이터가 손실되거나 손상될 수 있으며, 재전송을 보장하지 않음
            - 데이터 순서 미보장: 데이터가 송신한 순서대로 수신되지 않을 수 있음
            - 저오버헤드: 추가적인 제어 정보가 적어 전송 속도가 빠름

            소->소켓(socket) : 소켓 생성은 통신의 출발점입니다. 소켓은 네트워크 통신의 끝점을 나타내며, IP 주소와 포트 번호의 조합을 통해 통신을 설정
            말->바인더(bind) : 바인드는 소켓에 IP 주소와 포트 번호를 할당하는 단계입니다. 이 단계는 서버에서만 필요하며, 클라이언트는 일반적으로 바인드를 수행하지 않음.
            리->리슨(listen) : 리슨은 서버 소켓이 들어오는 연결 요청을 대기하도록 설정하는 단계입니다. 이 단계에서는 연결 대기열의 크기도 지정.
            아->엑셉트(accept) : 엑셉트는 들어오는 연결 요청을 수락하고, 새로운 소켓 객체를 반환하는 단계입니다. 이 새로운 소켓은 클라이언트와의 통신을 처리하는 데 사용됨.
            

    - 네트워크 프로그래밍에서 연결요청을 허용하는 소켓의 생성과정을 정리
 
        1단계 : 소켓 생성 (soket 함수호출)
        2단계 : IP 주소와 PORT번호 할당 (bind 함수호출)
        3단계 : 연결요청 가능상태로 변경(listen 함수호출)
        4다계 : 연결요청에 대한 수락 (accept 함수호출)

    - 리눅스 기반 파일 조작하기 
        - 저 수준 파일 입출력(Low-level File Access) 과 파일 디스크립터(File Descriptor)
            - 파일 디스크립터 
                - 0 : 표준입력 
                - 1 : 표준출력
                - 2 : 표준에러 
            
            - 파일 열기
                - O_CREAT : 필요하면 파일을 생성
                - O_TRUNC : 기존 데이터 전부 삭제
                - O_APPEND : 기존 데이터 보존하고 , 뒤에 이어서 저장
                - O_RDONLY : 읽기 전용으로 파일 오픈
                - O_WRONLY : 쓰기 전용으로 파일 오픈
                - o_RDWR : 읽기 , 쓰기 겸용으로 파일 오픈 


- 소켓의 프로토콜과 그에 따른 데이터 전송 특성

    - 프로토콜이란?
        - 컴퓨터 상호간의 대화에 필요한 통신규약 
    
    - 프로토콜 체계
        - PF_INET : IPv4 인터넷 프로토콜 체계
        - PF_INET6 : IPv6 인터넷 프로토콜 체

    - 소켓의 타입 1 : 연결지향형 소켓 (SOCK_STREAM)  == TCP
        - 중간에 데이터가 소멸되지 않고 목적지로 전송된다.
        - 전송 순서대로 데이터가 수신된다.
        - 전송되는 데이터의 경계(Boundary)가 존재하지 않는다.
        - 즉 , 연결지향형 소켓 하나는 다른 연결지향형 소켓 하나와만 연결이 가능하다. (소켓 대 소켓의 연결은 반드시 1대1이어야 한다.!)
        - 신뢰성 있는 순차적인 바이트 기반의 연결지향 데이터 전송 방식의소켓!
    
    - 소켓의 타입 2 : 비연결지향형 소켓 (SOCK_DGRAM) == UDP
        - 전송된 순서에 상관없이 가장 빠른 전송을 지향한다.
        - 전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다 
        - 전송되는 데이터의 경계(Boundary) 가 존재한다.
        - 한번에 전송할 수 있는 데이터의 크기가 제한된다.
        - 신뢰성과 순차적 데이터 전송을 보장하지 않는 , **고속의 데이터 전송을** 목적으로 하는 소켓!



- 소켓에 할당되는 IP주소와 PORT 번호 
    - IP: 인터넷상에서 데이터를 송수신할 목적으로 컴퓨터에게 부여하는 값
    - PORT 번호 : 컴퓨터에게 부여하는 값이 아닌, 프로그램상에서 생성되는 소켓을 구분 하기 위해 소켓에 부여되는 번호 

    - 인터넷 주소 
        - IPv4 : 4바이트 주소체계
        - IPv6 : 16바이트 주소체계
        - IPv4 와 IPv6의 차이점은 IP주소의 표현에 사용되는 바이트 크기에 있음 
    
    - **클래스 별 네트워크 주소와 호스트 주소의 경계**
        - IP 주소의 첫 번째 바이트만 보면 몇 바이트인지 판단이 가능 함
            - 클래스 A의 첫 번째 바이트 범위 (0이상 127이하)   - **즉 클래스 A의 첫 번째 비트는 항상 0으로 시작**
            - 클래스 B.의 첫 번째 바이트 범위 (128이상 191이하) - **즉 클래스 B의 첫 두 비트는 항상 10으로 시작**
            - 클래스 C의 첫 번째 바이트 범위 (192이상 223이하)  - **즉 클래스 C의 첫 세 비트는 항상 110으로 시작**
        - 기준이 정해져있음으로 데이터를 송수신할때 별도로 신경쓸 필요 없이 네트워크로 데이터가 이동하고 최종 목적지인 호스트로 데이터가 전송 됨 

    - **네트워크로 데이터가 전송된다는것은 네트워크를 구성하는 라우터(Router) 또는 스위치 (Switch)로 데이터가 전송됨을 뜻함.**
        - IP는 컴퓨터를 구분하는 목적으로만 존재하기 때문에 IP만 가지고있다면 원하는 목적지로 데이터를 전송할수는 있어도 최종 응용프로그램까지는 전달할 수 없기때문에 **PORT번호가 필요로 함** 

    - PORT 
        - 번호는 하나의 운영체제 내에서 소켓을 구분하는 목적으로 사용되기 때문에 하나의 운영체제 내에서 동일한 번호를 사용할 수 없음!
        - 16비트로 표현 됨 , 범위는 (-dltkd 65535이하) 까지 , 하지만 0부터 1023번까지는 예약번호이기때문에 제외한 다른값을 할당 해주어야 함
        - 중복이 불가능하지만 TCP , UDP 소켓은 PORT번호를 공유하지는 않기때문에 상관없음
        - 정리하자면 TCP > 9190 PORT번호 할당 했다면 > 다른 TCP 소켓에는 9190 번호 X > 하지만 UDP 소켓에서는 할당가능!

- IPv4 기반의 주소표현을 위한 구조체 
    - posix 사진
        - 이렇게 자료형을 별도로 정의 해둔 이유는 확장성을 **고려한 결과** 즉 int32_t 라는 자료형을 사용한다면 , 어떠한 경우에도 4바이트 자료형임을 보장받을 수 있다.

    - 구조체 sockaddr_in의 멤버에 대한 분석 
        - 주소체계
            - AF_INET : IPv4 인터넷 프로토콜에 적용하는 주소체계
            - AF_INET6: IPv6 인터넷 프로토콜에 적용하는 주소체계
            - AF_LOCAL: 로컬 통신을 위한 유닉스 프로토콜의 주소체계 

    - 네트워크 바이트 순서와 인터넷 주소 변환
        - **CPU에 따라서 4바이트 정수 1을 메모리공간에 저장하는 방식이 달라질 수 있음**
            - 순서 그대로 메모리에 저장하는 CPU가 있는 반면 , 거꾸로 저장하는 CPU도 존재하기 때문
            - 데이터의 저장순서가 다른것은 전송되어온 해석순서가 다름을 뜻하기 때문

        - 바이트 순서(Order)와 네트워크 바이트 순서
            - 빅 엔디안 (Big Endian) : 상위 바이트의 값을 작은 번지수에 저장하는 방식
                - ex: 0x1234567은 가장 나은 번지부터 0x12 0x34 0x56 0x78순서로 담긴다. (상위 바이트는 12이다.)
            - 리틀 엔디안(Little Endian) : 상위 바이트의 값을 큰 번지수에 저장하는 방식
                - ex: 00x1234567은 0x78 0x56 0x34 0x12 순서로 담긴다.
            
            - 데이터 송수신 과정에서 데이터 저장방식의 차이 문제가 발생할 수 있기때문에 송수신을 할때에는 약속이 필요 함
            - 보내는 쪽 , 받는 쪽 모두 BigEndian/ LittleEndian이든 상관없이 보내는 바이트의 수서는 낮은 주소로부터 전송 (빅에디안) 한다는것을 알려야 함 
            - 네트워크 바이트 순서는 BigEndian 기준 ! (낮은 주소의 데이터 번지부터 전송!) 낮은 주소를 significantbyte로 취급하라고 알려줌

        - 바이트 순서의 변환(Endian Conversions)
            - unsigned short htons(unsigned short);
            - unsigned short ntohs(unsigned short);
            - unsigned long htonl(unsigned long);
            - unsigned long ntonl(unsigned long);

            - htons에서의 h는 호스트(host) 바이트 순서를 의미
            - htons에서의 n은 네트워크(network) 바이트 순서를 의미