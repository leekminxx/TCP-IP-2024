# TCP-IP-2024
TCP/IP-2024


## 1일차 
- TCP/IP - cmd > ipconfig
    - 전송방식: TCP / UDP 
       - TCP (Transmission Control Protocol)
            - 연결 지향적: 데이터 전송 전에 송신자와 수신자 간에 연결을 확립
            - 신뢰성: 데이터가 손실되거나 손상되지 않도록 보장합니다. 손실된 데이터는 재전송
            - 데이터 순서 보장: 송신한 순서대로 데이터가 수신
            - 흐름 제어 및 혼잡 제어: 네트워크 혼잡을 방지하기 위해 데이터 전송 속도를 조절

       - UDP (User Datagram Protocol)

            - 비연결 지향적: 데이터 전송 전에 연결을 확립하지 않음
            - 신뢰성 부족: 데이터가 손실되거나 손상될 수 있으며, 재전송을 보장하지 않음
            - 데이터 순서 미보장: 데이터가 송신한 순서대로 수신되지 않을 수 있음
            - 저오버헤드: 추가적인 제어 정보가 적어 전송 속도가 빠름

            소->소켓(socket) : 소켓 생성은 통신의 출발점입니다. 소켓은 네트워크 통신의 끝점을 나타내며, IP 주소와 포트 번호의 조합을 통해 통신을 설정
            말->바인더(bind) : 바인드는 소켓에 IP 주소와 포트 번호를 할당하는 단계입니다. 이 단계는 서버에서만 필요하며, 클라이언트는 일반적으로 바인드를 수행하지 않음.
            리->리슨(listen) : 리슨은 서버 소켓이 들어오는 연결 요청을 대기하도록 설정하는 단계입니다. 이 단계에서는 연결 대기열의 크기도 지정.
            아->엑셉트(accept) : 엑셉트는 들어오는 연결 요청을 수락하고, 새로운 소켓 객체를 반환하는 단계입니다. 이 새로운 소켓은 클라이언트와의 통신을 처리하는 데 사용됨.
            

    - 네트워크 프로그래밍에서 연결요청을 허용하는 소켓의 생성과정을 정리
 
        1단계 : 소켓 생성 (soket 함수호출)
        2단계 : IP 주소와 PORT번호 할당 (bind 함수호출)
        3단계 : 연결요청 가능상태로 변경(listen 함수호출)
        4다계 : 연결요청에 대한 수락 (accept 함수호출)

    - 리눅스 기반 파일 조작하기 
        - 저 수준 파일 입출력(Low-level File Access) 과 파일 디스크립터(File Descriptor)
            - 파일 디스크립터 
                - 0 : 표준입력 
                - 1 : 표준출력
                - 2 : 표준에러 
            
            - 파일 열기
                - O_CREAT : 필요하면 파일을 생성
                - O_TRUNC : 기존 데이터 전부 삭제
                - O_APPEND : 기존 데이터 보존하고 , 뒤에 이어서 저장
                - O_RDONLY : 읽기 전용으로 파일 오픈
                - O_WRONLY : 쓰기 전용으로 파일 오픈
                - o_RDWR : 읽기 , 쓰기 겸용으로 파일 오픈 


- 소켓의 프로토콜과 그에 따른 데이터 전송 특성

    - 프로토콜이란?
        - 컴퓨터 상호간의 대화에 필요한 통신규약 
    
    - 프로토콜 체계
        - PF_INET : IPv4 인터넷 프로토콜 체계
        - PF_INET6 : IPv6 인터넷 프로토콜 체

    - 소켓의 타입 1 : 연결지향형 소켓 (SOCK_STREAM)  == TCP
        - 중간에 데이터가 소멸되지 않고 목적지로 전송된다.
        - 전송 순서대로 데이터가 수신된다.
        - 전송되는 데이터의 경계(Boundary)가 존재하지 않는다.
        - 즉 , 연결지향형 소켓 하나는 다른 연결지향형 소켓 하나와만 연결이 가능하다. (소켓 대 소켓의 연결은 반드시 1대1이어야 한다.!)
        - 신뢰성 있는 순차적인 바이트 기반의 연결지향 데이터 전송 방식의소켓!
    
    - 소켓의 타입 2 : 비연결지향형 소켓 (SOCK_DGRAM) == UDP
        - 전송된 순서에 상관없이 가장 빠른 전송을 지향한다.
        - 전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다 
        - 전송되는 데이터의 경계(Boundary) 가 존재한다.
        - 한번에 전송할 수 있는 데이터의 크기가 제한된다.
        - 신뢰성과 순차적 데이터 전송을 보장하지 않는 , **고속의 데이터 전송을** 목적으로 하는 소켓!



- 소켓에 할당되는 IP주소와 PORT 번호 
    - IP: 인터넷상에서 데이터를 송수신할 목적으로 컴퓨터에게 부여하는 값
    - PORT 번호 : 컴퓨터에게 부여하는 값이 아닌, 프로그램상에서 생성되는 소켓을 구분 하기 위해 소켓에 부여되는 번호 

    - 인터넷 주소 
        - IPv4 : 4바이트 주소체계
        - IPv6 : 16바이트 주소체계
        - IPv4 와 IPv6의 차이점은 IP주소의 표현에 사용되는 바이트 크기에 있음 
    
    - **클래스 별 네트워크 주소와 호스트 주소의 경계**
        - IP 주소의 첫 번째 바이트만 보면 몇 바이트인지 판단이 가능 함
            - 클래스 A의 첫 번째 바이트 범위 (0이상 127이하)   - **즉 클래스 A의 첫 번째 비트는 항상 0으로 시작**
            - 클래스 B.의 첫 번째 바이트 범위 (128이상 191이하) - **즉 클래스 B의 첫 두 비트는 항상 10으로 시작**
            - 클래스 C의 첫 번째 바이트 범위 (192이상 223이하)  - **즉 클래스 C의 첫 세 비트는 항상 110으로 시작**
        - 기준이 정해져있음으로 데이터를 송수신할때 별도로 신경쓸 필요 없이 네트워크로 데이터가 이동하고 최종 목적지인 호스트로 데이터가 전송 됨 

    - **네트워크로 데이터가 전송된다는것은 네트워크를 구성하는 라우터(Router) 또는 스위치 (Switch)로 데이터가 전송됨을 뜻함.**
        - IP는 컴퓨터를 구분하는 목적으로만 존재하기 때문에 IP만 가지고있다면 원하는 목적지로 데이터를 전송할수는 있어도 최종 응용프로그램까지는 전달할 수 없기때문에 **PORT번호가 필요로 함** 

    - PORT 
        - 번호는 하나의 운영체제 내에서 소켓을 구분하는 목적으로 사용되기 때문에 하나의 운영체제 내에서 동일한 번호를 사용할 수 없음!
        - 16비트로 표현 됨 , 범위는 (-dltkd 65535이하) 까지 , 하지만 0부터 1023번까지는 예약번호이기때문에 제외한 다른값을 할당 해주어야 함
        - 중복이 불가능하지만 TCP , UDP 소켓은 PORT번호를 공유하지는 않기때문에 상관없음
        - 정리하자면 TCP > 9190 PORT번호 할당 했다면 > 다른 TCP 소켓에는 9190 번호 X > 하지만 UDP 소켓에서는 할당가능!

- IPv4 기반의 주소표현을 위한 구조체 
    - posix 사진
        - 이렇게 자료형을 별도로 정의 해둔 이유는 확장성을 **고려한 결과** 즉 int32_t 라는 자료형을 사용한다면 , 어떠한 경우에도 4바이트 자료형임을 보장받을 수 있다.

    - 구조체 sockaddr_in의 멤버에 대한 분석 
        - 주소체계
            - AF_INET : IPv4 인터넷 프로토콜에 적용하는 주소체계
            - AF_INET6: IPv6 인터넷 프로토콜에 적용하는 주소체계
            - AF_LOCAL: 로컬 통신을 위한 유닉스 프로토콜의 주소체계 

    - 네트워크 바이트 순서와 인터넷 주소 변환
        - **CPU에 따라서 4바이트 정수 1을 메모리공간에 저장하는 방식이 달라질 수 있음**
            - 순서 그대로 메모리에 저장하는 CPU가 있는 반면 , 거꾸로 저장하는 CPU도 존재하기 때문
            - 데이터의 저장순서가 다른것은 전송되어온 해석순서가 다름을 뜻하기 때문

        - 바이트 순서(Order)와 네트워크 바이트 순서
            - 빅 엔디안 (Big Endian) : 상위 바이트의 값을 작은 번지수에 저장하는 방식
                - ex: 0x1234567은 가장 나은 번지부터 0x12 0x34 0x56 0x78순서로 담긴다. (상위 바이트는 12이다.)
            - 리틀 엔디안(Little Endian) : 상위 바이트의 값을 큰 번지수에 저장하는 방식
                - ex: 00x1234567은 0x78 0x56 0x34 0x12 순서로 담긴다.
            
            - 데이터 송수신 과정에서 데이터 저장방식의 차이 문제가 발생할 수 있기때문에 송수신을 할때에는 약속이 필요 함
            - 보내는 쪽 , 받는 쪽 모두 BigEndian/ LittleEndian이든 상관없이 보내는 바이트의 수서는 낮은 주소로부터 전송 (빅에디안) 한다는것을 알려야 함 
            - 네트워크 바이트 순서는 BigEndian 기준 ! (낮은 주소의 데이터 번지부터 전송!) 낮은 주소를 significantbyte로 취급하라고 알려줌

        - 바이트 순서의 변환(Endian Conversions)
            - unsigned short htons(unsigned short);
            - unsigned short ntohs(unsigned short);
            - unsigned long htonl(unsigned long);
            - unsigned long ntonl(unsigned long);

            - htons에서의 h는 호스트(host) 바이트 순서를 의미
            - htons에서의 n은 네트워크(network) 바이트 순서를 의미

            - s는 short 를 l은 long를 의미함 **(무엇보다 중요한것은 리눅스에서 long형은 4바이트라는 사실 short는 2바이트를 의미 PORT번호의 변환에 사용됨)**
            - htons : short 형 데이터를 호스트바이트순서에서 네트워크바이트 순서로 변환!
            - ntohs : short 형 데이터를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환! 
        

## 2일차
   -  인터넷 주소의 초기화
    - memset : 구조체를 초기화 시킬때 사용되는 함수  
    - memset 함수를 사용 하는 이유 : sockaddr_in 구조체 변수의 마지막 8byte변수는 사용하지 않기 때문에 모두 0으로 채울 필요가 있다 . 
   
   - 문자열 정보를 네트워크 바이트 순서의 정수로 변환하기 
    - sockaddr_in 안에서 주소정보를 저장하기 위해 선언된 멤버는 32비트 정수형으로 정의 되어있음

   - 소켓에 인터넷주소 할당하기 
    - bind 함수가 필요로 함 

   - TCP 와 UDP 에 대한 이해
    - SOCK_STREAM : TCP 소켓임을 의미
      두번째 인자의 경우, 데이터의 전송 방식에 따라 TCP 와 UDP로 나눌 수 있다.
      TCP는 연결지향형 방식으로, 신뢰성이 높다는 특징을 가진다. 데이터가 소실없이, 순서대로 전달되어야만 하는 응용프로그램들에 주로 이용된다.
      UDP는 비 연결지향형 방식으로, 빠른 전송을 지향한다. 실시간 화상과 같은 속도가 중요한 응용 프로그램들에 주로 사용된다.
      UDP 소켓을 원할 경우 SOCK_DGRAM으로 대체해준다.

   - LINK 계층 
    - 물리적인 영역의 표준화에 대한 결과 가장 기본이 되는 영역 LAN , WAN , MAN 과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역

   - IP 계층 
    - 목적지로 데이터를 전송하기 위해서 중간에 IP 프로토콜을 거친다 
    - 비연결지향적이며 신회 할 수 없는 프로토콜이다
    - 데이터를 전송할 때마다 경로를 선택해줌 > 경로상 문제가 발생하면 다른경로 추천 > 이 과정에서 데이터 손실 발생할 수 있음
    - 즉 , 오류발생에 대한 대비가 되어있지 않음 

   - TCP / UDP  계층 
    - IP 계층에서 경로의 검색을 해결해주기때문에 UDP 에서는 데이터 전송만 하면 됨 
    - 송수신을 담당하는 계층 (Tracnsport) 계층 이라고 함 
    - UDP 는 TCP 보다 상대적으로 간단 
    - TCP : 신뢰정있는 데이터 전송담당 ,, 하지만 IT기반

   - TCP 기반 서버 , 클라이언트 구현
    - TCP 서버에서의 기본적인 함수호출 순서
        - socket() 소켓생성 > bind() 소켓 주소할당 > listen() 연결요청 대기상태 > accept() 연결허용 > read()/write() 데이터 송수신 > close() 연결종료

        - bind 함수호출을 통해서 소켓에 주소까지 할당했으면 listen 함수호출을 통해서 '연결요청 대기  상태' 가 있음 listen 함수가 호출되어야 클라이언트가 연결요청을 할 수 있는 상태가 됨 연결요청을 위해서 connect 함수를 호출하면 오류 발생 > listen 함수호출 이후에 클라이언트의 연결요청이 들어왔다면 , **들어온 순서대로 연결요청을 수락해야 한다** 수락은 클라이언트와 데이터를 주고받을 수 있는 상태가 됨을 의미 > accept 함수는 호출성공 시 내부적으로 데이터 입출력에 사용할 소켓을 생성하고 그 소켓의 파일 디스크립터를 반환 **중요한점은 자동으로 생성되어 연결요청을 한 클라이언트와 연결까지 이루어짐** 

        - 함수호출 순서 사진

    - TCP기반 서버, 클라이언트의 함수호출 관계
        - 이 둘의 관계는 서로 독립된 과정이 아니기 때문에 하나의 과정으로 생각
            - 전체적인 정리를 하면 서버는 소켓 생성 이후에 bind, listen 함수의 연이은 호출을 통해 대기상태에 들어가고 > 클라이언트는 connect 함수호출을 통해서 연결요청 > 클라이언트는 서버 소켓의 listen 함수호출 이후에 connect 함수호출이 가능 > 클라이언트가 connect 함수를 호출하기에 앞서 서버가 accept함수를 먼저 호출할 수 있음 ..../ 클라이언트가 connect 함수를 호출할 때까지 서버는 accept 함수가 호출된 위치에서 블로킹 상태에 놓임

        - 함수호출  관계 사진 

    - lterative 서버의 구현 
        - 계속해서 들어오는 클라이언트의 연결요청을 수락하기 위해서는 반복문을 삽입해서 accept함수를 반복 호출 

    - lterative 서버의 함수호출 순서 사진 


        - accept 함수가 호출된 다음에 입출력 함수인 read , write 함수를 호출 > close 함수를 호출하지만 accept 함수의 호출과정에서 생성된 소켓을 대상으로 하는 close 함수까지 호출되었다면 한 클라이언트에 대한 서비스가 완료된것 또 다른 클라이언트에게 서비스를 제공하기 위해서는 또 accept 함수부터 호출해야하는 번거러움이 발생 

    - server client 연결 한 내용 적어놓기 

    - lterative 에코 서버 , 에코 클라이언트
        - 서버는 한 순간에 하나의 클라이언트와 연결되어 에코 서비스를 제공한다.
        - 서버는 총 다섯 개의 클라이언트에게 순차적으로 서비스를 제공하고 종료된다.
        - 클라이언트는 프로그램 사용자로부터 문자열 데이터를 입력 받아서 서버에 전송한다.
        - 서버는 전송 받은 문자열 데이터를 클라이언트에게 재전송한다. 즉 , 에코  시킨다
        - 서버와 클라이언트간의 문자열 에코는 클라이언트가 Q를 입력할 때까지 계속한다.

    ```c
    write(sock, message, strlen(message));
    str_len=read(sock, message, BUF_SIZE-1);
    message[str_len]=0;
    printf("Message from server: %s", message);
    ``` 
    - 지금 코드에는 read, write 함수가 호출될 때마다 문자열 단위로 실제 입출력이 이루어진다.

- 윈도우 기반 에코 서버
      - 사진 첨부
      -  TCP 서버에서 listen 함수호출을 통해 연결요청 대기상태에 들어가면 클라이언트가 connect() 함수호출을 통해서 연결요청을 할 수 있다.

      - listen 함수 호출이후 클라이언트의 연결요청이 들어왔다면, 들어온 순서대로 연결요청을 수락하고 클라이언트와 데이터를 주고받을 수 있는 상태가 되는데, 데이터를 주고받기 위해서는 소켓이 필요하다.
        서버소켓은 문지기 역할을 하는 소켓이니까 클라이언트와 데이터 송수신을 위해서는 연결요청 수락과 함께 소켓을 하나 더 만들어야 한다.

