# TCP-IP-2024
TCP/IP-2024


## 1일차 
- TCP/IP - cmd > ipconfig
    - 전송방식: TCP / UDP 
       - TCP (Transmission Control Protocol)
            - 연결 지향적: 데이터 전송 전에 송신자와 수신자 간에 연결을 확립
            - 신뢰성: 데이터가 손실되거나 손상되지 않도록 보장합니다. 손실된 데이터는 재전송
            - 데이터 순서 보장: 송신한 순서대로 데이터가 수신
            - 흐름 제어 및 혼잡 제어: 네트워크 혼잡을 방지하기 위해 데이터 전송 속도를 조절

       - UDP (User Datagram Protocol)

            - 비연결 지향적: 데이터 전송 전에 연결을 확립하지 않음
            - 신뢰성 부족: 데이터가 손실되거나 손상될 수 있으며, 재전송을 보장하지 않음
            - 데이터 순서 미보장: 데이터가 송신한 순서대로 수신되지 않을 수 있음
            - 저오버헤드: 추가적인 제어 정보가 적어 전송 속도가 빠름

            소->소켓(socket) : 소켓 생성은 통신의 출발점입니다. 소켓은 네트워크 통신의 끝점을 나타내며, IP 주소와 포트 번호의 조합을 통해 통신을 설정
            말->바인더(bind) : 바인드는 소켓에 IP 주소와 포트 번호를 할당하는 단계입니다. 이 단계는 서버에서만 필요하며, 클라이언트는 일반적으로 바인드를 수행하지 않음.
            리->리슨(listen) : 리슨은 서버 소켓이 들어오는 연결 요청을 대기하도록 설정하는 단계입니다. 이 단계에서는 연결 대기열의 크기도 지정.
            아->엑셉트(accept) : 엑셉트는 들어오는 연결 요청을 수락하고, 새로운 소켓 객체를 반환하는 단계입니다. 이 새로운 소켓은 클라이언트와의 통신을 처리하는 데 사용됨.
            

    - 네트워크 프로그래밍에서 연결요청을 허용하는 소켓의 생성과정을 정리
 
        1단계 : 소켓 생성 (soket 함수호출)
        2단계 : IP 주소와 PORT번호 할당 (bind 함수호출)
        3단계 : 연결요청 가능상태로 변경(listen 함수호출)
        4다계 : 연결요청에 대한 수락 (accept 함수호출)

    - 리눅스 기반 파일 조작하기 
        - 저 수준 파일 입출력(Low-level File Access) 과 파일 디스크립터(File Descriptor)
            - 파일 디스크립터 
                - 0 : 표준입력 
                - 1 : 표준출력
                - 2 : 표준에러 
            
            - 파일 열기
                - O_CREAT : 필요하면 파일을 생성
                - O_TRUNC : 기존 데이터 전부 삭제
                - O_APPEND : 기존 데이터 보존하고 , 뒤에 이어서 저장
                - O_RDONLY : 읽기 전용으로 파일 오픈
                - O_WRONLY : 쓰기 전용으로 파일 오픈
                - o_RDWR : 읽기 , 쓰기 겸용으로 파일 오픈 


- 소켓의 프로토콜과 그에 따른 데이터 전송 특성

    - 프로토콜이란?
        - 컴퓨터 상호간의 대화에 필요한 통신규약 
    
    - 프로토콜 체계
        - PF_INET : IPv4 인터넷 프로토콜 체계
        - PF_INET6 : IPv6 인터넷 프로토콜 체

    - 소켓의 타입 1 : 연결지향형 소켓 (SOCK_STREAM)  == TCP
        - 중간에 데이터가 소멸되지 않고 목적지로 전송된다.
        - 전송 순서대로 데이터가 수신된다.
        - 전송되는 데이터의 경계(Boundary)가 존재하지 않는다.
        - 즉 , 연결지향형 소켓 하나는 다른 연결지향형 소켓 하나와만 연결이 가능하다. (소켓 대 소켓의 연결은 반드시 1대1이어야 한다.!)
        - 신뢰성 있는 순차적인 바이트 기반의 연결지향 데이터 전송 방식의소켓!
    
    - 소켓의 타입 2 : 비연결지향형 소켓 (SOCK_DGRAM) == UDP
        - 전송된 순서에 상관없이 가장 빠른 전송을 지향한다.
        - 전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다 
        - 전송되는 데이터의 경계(Boundary) 가 존재한다.
        - 한번에 전송할 수 있는 데이터의 크기가 제한된다.
        - 신뢰성과 순차적 데이터 전송을 보장하지 않는 , **고속의 데이터 전송을** 목적으로 하는 소켓!



- 소켓에 할당되는 IP주소와 PORT 번호 
    - IP: 인터넷상에서 데이터를 송수신할 목적으로 컴퓨터에게 부여하는 값
    - PORT 번호 : 컴퓨터에게 부여하는 값이 아닌, 프로그램상에서 생성되는 소켓을 구분 하기 위해 소켓에 부여되는 번호 

    - 인터넷 주소 
        - IPv4 : 4바이트 주소체계
        - IPv6 : 16바이트 주소체계
        - IPv4 와 IPv6의 차이점은 IP주소의 표현에 사용되는 바이트 크기에 있음 
    
    - **클래스 별 네트워크 주소와 호스트 주소의 경계**
        - IP 주소의 첫 번째 바이트만 보면 몇 바이트인지 판단이 가능 함
            - 클래스 A의 첫 번째 바이트 범위 (0이상 127이하)   - **즉 클래스 A의 첫 번째 비트는 항상 0으로 시작**
            - 클래스 B.의 첫 번째 바이트 범위 (128이상 191이하) - **즉 클래스 B의 첫 두 비트는 항상 10으로 시작**
            - 클래스 C의 첫 번째 바이트 범위 (192이상 223이하)  - **즉 클래스 C의 첫 세 비트는 항상 110으로 시작**
        - 기준이 정해져있음으로 데이터를 송수신할때 별도로 신경쓸 필요 없이 네트워크로 데이터가 이동하고 최종 목적지인 호스트로 데이터가 전송 됨 

    - **네트워크로 데이터가 전송된다는것은 네트워크를 구성하는 라우터(Router) 또는 스위치 (Switch)로 데이터가 전송됨을 뜻함.**
        - IP는 컴퓨터를 구분하는 목적으로만 존재하기 때문에 IP만 가지고있다면 원하는 목적지로 데이터를 전송할수는 있어도 최종 응용프로그램까지는 전달할 수 없기때문에 **PORT번호가 필요로 함** 

    - PORT 
        - 번호는 하나의 운영체제 내에서 소켓을 구분하는 목적으로 사용되기 때문에 하나의 운영체제 내에서 동일한 번호를 사용할 수 없음!
        - 16비트로 표현 됨 , 범위는 (-dltkd 65535이하) 까지 , 하지만 0부터 1023번까지는 예약번호이기때문에 제외한 다른값을 할당 해주어야 함
        - 중복이 불가능하지만 TCP , UDP 소켓은 PORT번호를 공유하지는 않기때문에 상관없음
        - 정리하자면 TCP > 9190 PORT번호 할당 했다면 > 다른 TCP 소켓에는 9190 번호 X > 하지만 UDP 소켓에서는 할당가능!

- IPv4 기반의 주소표현을 위한 구조체 
    - posix 사진
        - 이렇게 자료형을 별도로 정의 해둔 이유는 확장성을 **고려한 결과** 즉 int32_t 라는 자료형을 사용한다면 , 어떠한 경우에도 4바이트 자료형임을 보장받을 수 있다.

    - 구조체 sockaddr_in의 멤버에 대한 분석 
        - 주소체계
            - AF_INET : IPv4 인터넷 프로토콜에 적용하는 주소체계
            - AF_INET6: IPv6 인터넷 프로토콜에 적용하는 주소체계
            - AF_LOCAL: 로컬 통신을 위한 유닉스 프로토콜의 주소체계 

    - 네트워크 바이트 순서와 인터넷 주소 변환
        - **CPU에 따라서 4바이트 정수 1을 메모리공간에 저장하는 방식이 달라질 수 있음**
            - 순서 그대로 메모리에 저장하는 CPU가 있는 반면 , 거꾸로 저장하는 CPU도 존재하기 때문
            - 데이터의 저장순서가 다른것은 전송되어온 해석순서가 다름을 뜻하기 때문

        - 바이트 순서(Order)와 네트워크 바이트 순서
            - 빅 엔디안 (Big Endian) : 상위 바이트의 값을 작은 번지수에 저장하는 방식
                - ex: 0x1234567은 가장 나은 번지부터 0x12 0x34 0x56 0x78순서로 담긴다. (상위 바이트는 12이다.)
            - 리틀 엔디안(Little Endian) : 상위 바이트의 값을 큰 번지수에 저장하는 방식
                - ex: 00x1234567은 0x78 0x56 0x34 0x12 순서로 담긴다.
            
            - 데이터 송수신 과정에서 데이터 저장방식의 차이 문제가 발생할 수 있기때문에 송수신을 할때에는 약속이 필요 함
            - 보내는 쪽 , 받는 쪽 모두 BigEndian/ LittleEndian이든 상관없이 보내는 바이트의 수서는 낮은 주소로부터 전송 (빅에디안) 한다는것을 알려야 함 
            - 네트워크 바이트 순서는 BigEndian 기준 ! (낮은 주소의 데이터 번지부터 전송!) 낮은 주소를 significantbyte로 취급하라고 알려줌

        - 바이트 순서의 변환(Endian Conversions)
            - unsigned short htons(unsigned short);
            - unsigned short ntohs(unsigned short);
            - unsigned long htonl(unsigned long);
            - unsigned long ntonl(unsigned long);

            - htons에서의 h는 호스트(host) 바이트 순서를 의미
            - htons에서의 n은 네트워크(network) 바이트 순서를 의미

            - s는 short 를 l은 long를 의미함 **(무엇보다 중요한것은 리눅스에서 long형은 4바이트라는 사실 short는 2바이트를 의미 PORT번호의 변환에 사용됨)**
            - htons : short 형 데이터를 호스트바이트순서에서 네트워크바이트 순서로 변환!
            - ntohs : short 형 데이터를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환! 
        

## 2일차
   -  인터넷 주소의 초기화
    - memset : 구조체를 초기화 시킬때 사용되는 함수  
    - memset 함수를 사용 하는 이유 : sockaddr_in 구조체 변수의 마지막 8byte변수는 사용하지 않기 때문에 모두 0으로 채울 필요가 있다 . 
   
   - 문자열 정보를 네트워크 바이트 순서의 정수로 변환하기 
    - sockaddr_in 안에서 주소정보를 저장하기 위해 선언된 멤버는 32비트 정수형으로 정의 되어있음

   - 소켓에 인터넷주소 할당하기 
    - bind 함수가 필요로 함 

   - TCP 와 UDP 에 대한 이해
    - SOCK_STREAM : TCP 소켓임을 의미
      두번째 인자의 경우, 데이터의 전송 방식에 따라 TCP 와 UDP로 나눌 수 있다.
      TCP는 연결지향형 방식으로, 신뢰성이 높다는 특징을 가진다. 데이터가 소실없이, 순서대로 전달되어야만 하는 응용프로그램들에 주로 이용된다.
      UDP는 비 연결지향형 방식으로, 빠른 전송을 지향한다. 실시간 화상과 같은 속도가 중요한 응용 프로그램들에 주로 사용된다.
      UDP 소켓을 원할 경우 SOCK_DGRAM으로 대체해준다.

   - LINK 계층 
    - 물리적인 영역의 표준화에 대한 결과 가장 기본이 되는 영역 LAN , WAN , MAN 과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역

   - IP 계층 
    - 목적지로 데이터를 전송하기 위해서 중간에 IP 프로토콜을 거친다 
    - 비연결지향적이며 신회 할 수 없는 프로토콜이다
    - 데이터를 전송할 때마다 경로를 선택해줌 > 경로상 문제가 발생하면 다른경로 추천 > 이 과정에서 데이터 손실 발생할 수 있음
    - 즉 , 오류발생에 대한 대비가 되어있지 않음 

   - TCP / UDP  계층 
    - IP 계층에서 경로의 검색을 해결해주기때문에 UDP 에서는 데이터 전송만 하면 됨 
    - 송수신을 담당하는 계층 (Tracnsport) 계층 이라고 함 
    - UDP 는 TCP 보다 상대적으로 간단 
    - TCP : 신뢰정있는 데이터 전송담당 ,, 하지만 IT기반

   - TCP 기반 서버 , 클라이언트 구현
    - TCP 서버에서의 기본적인 함수호출 순서
        - socket() 소켓생성 > bind() 소켓 주소할당 > listen() 연결요청 대기상태 > accept() 연결허용 > read()/write() 데이터 송수신 > close() 연결종료

        - bind 함수호출을 통해서 소켓에 주소까지 할당했으면 listen 함수호출을 통해서 '연결요청 대기  상태' 가 있음 listen 함수가 호출되어야 클라이언트가 연결요청을 할 수 있는 상태가 됨 연결요청을 위해서 connect 함수를 호출하면 오류 발생 > listen 함수호출 이후에 클라이언트의 연결요청이 들어왔다면 , **들어온 순서대로 연결요청을 수락해야 한다** 수락은 클라이언트와 데이터를 주고받을 수 있는 상태가 됨을 의미 > accept 함수는 호출성공 시 내부적으로 데이터 입출력에 사용할 소켓을 생성하고 그 소켓의 파일 디스크립터를 반환 **중요한점은 자동으로 생성되어 연결요청을 한 클라이언트와 연결까지 이루어짐** 

        - 함수호출 순서 (사진)

    - TCP기반 서버, 클라이언트의 함수호출 관계
        - 이 둘의 관계는 서로 독립된 과정이 아니기 때문에 하나의 과정으로 생각
            - 전체적인 정리를 하면 서버는 소켓 생성 이후에 bind, listen 함수의 연이은 호출을 통해 대기상태에 들어가고 > 클라이언트는 connect 함수호출을 통해서 연결요청 > 클라이언트는 서버 소켓의 listen 함수호출 이후에 connect 함수호출이 가능 > 클라이언트가 connect 함수를 호출하기에 앞서 서버가 accept함수를 먼저 호출할 수 있음 ..../ 클라이언트가 connect 함수를 호출할 때까지 서버는 accept 함수가 호출된 위치에서 블로킹 상태에 놓임

        - 함수호출  관계 (사진) 

    - lterative 서버의 구현 
        - 계속해서 들어오는 클라이언트의 연결요청을 수락하기 위해서는 반복문을 삽입해서 accept함수를 반복 호출 

    - lterative 서버의 함수호출 순서 (사진) 


        - accept 함수가 호출된 다음에 입출력 함수인 read , write 함수를 호출 > close 함수를 호출하지만 accept 함수의 호출과정에서 생성된 소켓을 대상으로 하는 close 함수까지 호출되었다면 한 클라이언트에 대한 서비스가 완료된것 또 다른 클라이언트에게 서비스를 제공하기 위해서는 또 accept 함수부터 호출해야하는 번거러움이 발생 

    - server client 연결 한 내용 적어놓기 

    - lterative 에코 서버 , 에코 클라이언트
        - 서버는 한 순간에 하나의 클라이언트와 연결되어 에코 서비스를 제공한다.
        - 서버는 총 다섯 개의 클라이언트에게 순차적으로 서비스를 제공하고 종료된다.
        - 클라이언트는 프로그램 사용자로부터 문자열 데이터를 입력 받아서 서버에 전송한다.
        - 서버는 전송 받은 문자열 데이터를 클라이언트에게 재전송한다. 즉 , 에코  시킨다
        - 서버와 클라이언트간의 문자열 에코는 클라이언트가 Q를 입력할 때까지 계속한다.

    ```c
    write(sock, message, strlen(message));
    str_len=read(sock, message, BUF_SIZE-1);
    message[str_len]=0;
    printf("Message from server: %s", message);
    ``` 
    - 지금 코드에는 read, write 함수가 호출될 때마다 문자열 단위로 실제 입출력이 이루어진다.

- 윈도우 기반 에코 서버
      - 사진 첨부
      -  TCP 서버에서 listen 함수호출을 통해 연결요청 대기상태에 들어가면 클라이언트가 connect() 함수호출을 통해서 연결요청을 할 수 있다.

      - listen 함수 호출이후 클라이언트의 연결요청이 들어왔다면, 들어온 순서대로 연결요청을 수락하고 클라이언트와 데이터를 주고받을 수 있는 상태가 되는데, 데이터를 주고받기 위해서는 소켓이 필요하다.
        서버소켓은 문지기 역할을 하는 소켓이니까 클라이언트와 데이터 송수신을 위해서는 연결요청 수락과 함께 소켓을 하나 더 만들어야 한다.

## 3일차 
- UDP 기반 서버 / 클라이언트
    - UDP 소켓의 특성 : 편지를 예로 들면 알기 쉽게 할 수 있음 편지를 보내기 위해서는 편지봉투에 , 보내는 사람 , 받는 사람의 주소정보를 써 넣어야 함 마지막으로 우체통에 넣는것까지 적용하면 되는데 
    편지 특성상 보내고 나서 상대방의 수신여부를 알 수 는 없음 , 편지가 이동되는 중에는 편지가 분실될 일은 적음 , 즉 편지는 신뢰할 수 없는 전송방법 (UDP)는 신뢰할 수 없는 전송방법을 제공

       - UDP 는 TCP 보다 훨씬 간결한 구조로 설계되어 있음 , ACK 와 같은 응답 메시지를 보내는 일도 없음
       - SUE와 같이 패킷에 번호를 부여하는 일도 없음 
       - TCP 보다 훨씬 좋은 성능을 보여준다
    
    - UDP 의 역할 
        - UDP 에서는 흐름제어가 존재하지 않음 (TCP와 UCP 의 가장 큰 차이)
        - **UDP의 역할 중 가장 중요한 것은 호스트로 수신된 패킷을 PORT 정보를 참조하여 최종 목적지인 UDP 소켓에 전달하는것**

    - TCP 와의 차이 
        - TCP 소켓을 생성하고 나서 데이터를 전송하는 경우에는 , 주소 정보를 따로 추가하는 과정이 필요 없음 (TCP 소켓은 목적지에 해당하는 소켓과 연결된 상태이기 때문에)
        - UDP 소켓은 연결상태를 유지하지 않으므로 (UDP 소켓은 단순 우체통의 역할만 함) 데이터를 전송할때마다 주소정보를 별도로 추가해야 한다. 

    - UDP 를 효율적으로 사용하는 방법
        - 데이터 송수신 이전, 이후에 거치는 연결설정 및 해제과정
        - 데이터 송수신 과정에서 거치는 신뢰정보장을 위한 흐름제어

- UDP기반 서버 / 클라이언트의 구현
    - UDP에서의 서버와 클라이언트는 연결되어 있지 않음
    - UDP에서는 서버 , 클라이언트 상관없이 하나의 소켓만 있으면 가능
    - UDP 기반의 데이터 입출력 함수 
       
    - UDP 클라이언트 소켓의 주소정보 할당
        - IP와 PORT를 소켓에 할당하는 부분이 없음
        - 자동으로 connect 함수호출시 연결되는 TCP 클라이언트와 다르게 작용
        - 데이터를 전송하는 sendto 함수호출 이전에 해당 소켓에 주소정보가 할당되어 있어야함 
        - 따라서 bind 함수를 호출해서 주소정보를 할당 . (TCP UDP를 가리지 않고 할당 됨으로)

    - connected UDP 소켓 , unconnected UDP 소켓 
        - TCP 소켓에는 데이터를 전송할 목적지의 IP와 PORT 번호를 등록하는 반면 , UDP 소켓에는 데이터를 전송할 목적지의 IP와 PORT 번호를 등록하지 않는다 . 때문에 sendto 함수호출을 통한 데이터 전송과정을 나눔
            - 1단계 : UDP 소켓에 목적지의 IP와 PORT번호 등록
            - 2단계 : 데이터 전송
            - 3단계 : UDP 소켓에 등록된 목적지 정보 삭제 
                - 즉 , sendto 함수가 호출될 때마다 이러한 과정을 반복 (목적지의 주소정보가 계속해서 변경되기 때문에 하나의 UDP 소켓을 이용해서 다양한 목적지로 데이터 전송이 가능한 것)
                - 이것처럼 등록되어 있찌 않은 소켓을'unconnected소켓'이라 하고 , 반대로 목적지 정보가 등록되어 있는 소켓을 'connected 소켓' 이라고 함 
        - connected UDP 소켓 생성
         - UDP 소켓을 대상으로 connect 함수만 호출해주면 됨
         ```c
         sock=socket(PF_INET, SOCK_DGRAM, 0);
         memset(&adr, 0, sizeof(adr));
         adr.sin_family=AF_INET;  // 주소 패밀리를 설정 AF_INET: IPv4 사용
         adr.sin_addr.s_addr=  // IP 주소를 설정 Ex) inet_addr("127.0.0.1")를 사용할 수 있음
         adr.sin_port= // 포트 번호를 설정 Ex) htons(12345)와 같이 사용할 수 있음
         connect(sock, (struct sockaddr*)&adr, sizeof(adr)); // 소켓을 지정한 주소와 포트 번호로 연결
         ```
         - q뿐만 아니라 송수신의 대상이 정재졌기 때문에 sendto, recvfrom 함수가 아닌 write, read함수의 호출로도 데이터를 송수신할 수 있음 

- 소켓의 연결종료
    - 일방적인 연결종료의 문제점 
        - 완전 종료 함수 (데이터 송수신 전송 더 이상 불가능한 상황을 의미)
            - 리눅스 : close , 윈도우 : closesocket 함수

    - 소켓과 스트림(Stream)
        - 스트림이 형성된 상태 : 소켓을 통해 두 호스트가 연결되면 , 그 다음부터 상호작용 송수신이 가능한 상태가 됨
        - 물의 흐름과 같다고 보면 됨 , 물의 흐름처럼 한쪽 방향으로만 설정됨 
        - **양방향 통신을 위해서는 두 개의 스트림이 필요**

    - 우아한 종료를 위한 shutdown 함수
        - 앞에서 말한 내용의 두 개의 스트림을 한번에 끊어내는 것이 아닌 이 중 하나만의 스트림만 끊어내는것을 설명 **(일방적인 종료)는 한번에 모두가 끊어지기 때문에 거리가 멀다**
        - Half-close 함수 사용
        ```c
        #include <sys/socket.h>

        int shutdown(int sock, int howto);
        ```
        - sock : 종료할 소켓의 파일 디스크립터 전달.
        - howto : 종료방법에 대한 정보 전달.
        - 위의 함수를 호출할 때 두 번째 매개변수에 전달되는 인자에 따라서 종료의 방법이 결정됨 
            - 두 번째 매개변수에 전달 될 수 있는 인자의 종류
                - SHUT_RD : 입력 스트림 종료 / 더 이상 데이터를 수신할 수 없는 상태가 됨 (혹시나 전달되어도 허용되지 않거나 지워짐)
                - SHUT_WR : 출력 스트림 종료 / 
                - SHUT_RDWR : 입출력 스트림 종료


- 도메인
    - DNS : IP주소와 이름 사이에서 변환을 수행하는 시스템을 가리켜 'DNS(Domain Name System)' 이라고 하며 DNS 중심에는 DNS 서버가 있음
    - 도메인 이름을 이용해서 IP주소 얻어오기 
        - hostent 라는 구조체의 변수정의
            ```c
            struct hostent
            {
                char * h_name;  // official name
                char ** h_aliases; // alias list
                int h_addrtype; //gist address type
                int h_length  // address length
                char ** h_addr_list  // address list
            }
            // 도메인 이름을 IP로 변환하는 경우에는 h_addr_list만 신경쓰면 됨
            ```
            - h_name : 공식 도메인 이름 저장 해당 홈페이지를 대표하는 도메인 이름이라는 의미를 담고 있지만 실제 우리에게 잘 알려진 유명 회사의 도메인 이름이 공식 도메인 이름으로 등록되지 않은 경우도 많음
            - h_aliases : 같은 메인 페이지여도 다른 도메인 이름으로 접속할 수 있는 경우 다른 도메인 이름의 지정이 가능 정보는 h_alsiases 를 통해 얻을 수 있다
            - h_addrtype : IPv4 , IPv6 둘다 지원 h_addr_list 로 변환된 IP주소의 주소체계정보를 반환
            - h_length : 함수호출의 결과 IP주소가 담긴다 IPv4의 경우는 4바이트 IPv6 의 경우에는 16바이트
            - h_addr_list : IP주소가 **정수의 형태로 변환된다 . 접속자 수가 많은 서버는 하나의 도메인 이름에 대응하는 IP를 여러개 둬서 둘 이상의 서버로 부하를 분산** , 이 경우에도 이 멤버를 통해 모든 IP의 주소정보를 얻을 수 있다 

- 소켓의 다양한 옵션
    - getsockopt & setsockopt
        ```c
        #include <sys/socket.h>
        int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen);
        // sock : 옵션확인을 위한 소켓의 파일 디스크립터 전달.
        // level : 확인할 옵션의 프로토콜 레벨 전달.
        // optname : 확인할 옵션의 이름 전달. 
        // optval : 확인결과의 저장을 위한 버퍼의 주소 값 전달.
        // optlen : 네 번째 매개변수 optval로 전달된 주소 값의 버퍼크기를 담고 있는 변수의 주소 값 전달, 함수호출이 완료되면 이 변수에는 네 번째 인자를 통해 반환된 옵션정보의 크기가 바이트 단위로 계산되어 저장된다.
        ```
        
        ```c
        #include <sys/socket.h>
        int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);
        // sock : 옵션변경을 위한 소켓의 파일 디스크립터 전달.
        // level : 변경할 옵션의 프로토콜 레벨 전달.
        // optname : 변경할 옵션의 이름 전달.
        // optval : 변경할 옵션정보를 저장한 버퍼의 주소 값 전달 
        // optlen : 네 번째 매개변수 optval로 전달된 옵션정보의 바이트 단위 크기 전달.
        ```

- SO_SNDBUF & SO_RCVBUF 
    - SO_RCVBUF 는 입력버퍼의 크기와 관련된 옵션 , SO_SNDBUF 는 출력버퍼의 크기와 관련된 옵션 
    - 이 두 옵션을 이용해서 **버퍼의 크기를 참조 뿐 아니라 변경도 가능**
    - 소켓이 생성되면 기본적으로 입력버퍼와 출력버퍼가 생성
    - 소켓의 타입은 소켓 생성시 한번 결정되면 변경이 불가능하다!


- SO_REUSEADDR 
    - Time-wait상태는 상대적으로 중요함 
        - 클라이언트를 먼저 종료시키고 서버를 종료하면 재실행이 바로 진행되지만 , 서버를 먼저 종료하고 클라이언트를 종료시키면 재 실행 시 bind() error발생 -> 3분뒤 다시 실행 해야 함  / 빠르게 다시 시작하고 싶으면 PORT 번호를 바꿔주면 가능! **(서버는 종료되지만 Time-wait때문에 ex(10010번 PORT 가 살아있어서 기다려줘야하는것 , 기존에 사용하던 PORT를 바로 사용못하는 이유))** 

    - 주소의 재할당 
        - 네트워크나 오류가 발생하여 Time-wait상태가 발생하고 길어질 수 밖에 없는 문제의 상황이 올 수 도있음 
        - 해결방안으로 SO_REUSEADDR 의 상태를 변경하면 되는데 Time-wait 상태에 PORT 번호를 새로 시작 하는 소켓에 할당 되게 할 수 있음 
        - SO_REUSEADDR의 디폴트 값 0 은 : Time-wait 상태에 있는 소켓의 PORT 번호할당이 불가 를 나타냄
        - 이 값을 1로 변경해주면 해결이 됨

        ```c
        optlen = sizeof(option);
        option = TRUE;
        setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (void*)&option, optlen);
        // reuseadr_eserver.c 언제든 사용가능한 상태로 만들어주는 코드
        ```

- 프로세스(실행중인 프로그램) 이해
    - 두 가지 유형의 서버
        - 대표적인 다중접속 서버의 구현 모델
            - 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스 제공 (Linux에 적합)
            - 멀티플렉싱 기반 서버 : 입출력 대상을 묶어서 관리하는 방식으로 서비스 제공
            - 멀티쓰레딩 기반 서버 : 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 제공
    - 싱글코어도 5개의 프로세스가 진행되는것 처럼 보이는 이유는 CPU가 빠르기 때문에 빠르게 돌아가면서 
        보여지는것이 동시에 보이는것 처럼 보일정도로 빠르기 때문에 (코어수가 많을수록 더 많이 느낌)

    - 프로세스 ID
        - 모든 프로세스는 생성되는 형태에 상관없이 운영체제가 ID를 지정해줌
        - 2이상의 정수 형태를 가지고있음
        - **숫자1은 운영체제가 시작되자마자 실행되는(운영체제를 돕는)프로세스에게 할당되기때문**
    
    - fork 함수호출을 통한 프로세스 생성(멀티프로세스 기반 서버의 구현에 사용)
        - 이미 실행중인 fork 함수를 호출한 (호출한 부모프로세스의 복사본을 생성)
        - 그 다음 두 프로세스는 모두 fork 함수의 호출 이후 문장을 실행함
        - **완전 동일 메모리 영역까지 동일하게 복사되기 때문에 fork 함수의 변환 값을 기준으로 나뉘도록 프로그래밍을 해야함**
        - 부모 프로세스 : fork 함수의 반환 값은 자식 프로세스의 ID를 가지게 됨
        - 자식 프로세스 : fork 함수의 반환 값은 0
        - 반환값은 부모 프로세스로 다시 감 > 호출을 부모 프로세스에서 하기 때문에 
        - fork 함수호출 (그림)
        - ```c
            #include <unistd.h>
            pid_t fork(void);
          ```
- 프로세스 & zombie 프로세스 
    - 프로세스를 완벽히 종료시키지 않고 대충만 소멸시켜둔다면 좀비프로세스가 될 가능성이 있음(중요한 리소스를 차지할 수 있음)
    - exit 함수로 전달되는 인자 값과 main 함수의 return 문에 의해 반환되는 값 모두 운영체제로 전달 > 이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸 시키지 않는데 이 상황을 좀비 프로세스라고 한다. 
    - 해당 자식 프로세스를 생성한 부모 프로세스에게 exit 함수의 인자 값이나 return 문의 반환 값이 전달 되어야 함.
    - 전달 해주는 방식 : 부모 프로세스의 적극적인 요청이 있어야 (함수 호출) 함 
        
        - (좀비 프로세스의 생성이유)fork 함수의 호출로 생성된 자식 프로세스가 종료되는 상황 두 가지
            - 인자를 전달하면서 exit를 호출하는경우
            - main 함수에서 reutrn문을 실행하면서 값을 반환하는 경우 

